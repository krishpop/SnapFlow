Common.h
	Contains type definitions. Key and Value are uint64 types. Also has functions to GetTime, get a random double, sleep, and convert integers to/from string.


txn.h/txn.cc
	-TxnStatus is an enum to hold the status of the transaction
	-Constructur sets the status_ (of type TxnStatus) to INCOMPLETE. Virtual destructor and clone().
	-Pure Virtual Run() function (should contain the transaction's method logic)
	- Status() is a getter method for status_
	- CheckReadWriteSets() checks for overlaps in the read and write sets of this transaction.
	- Read() function reads records from database. If a record matches a given key, it setls value to the record value (which I believe is an array of...) and returns true.
		- If a given Key is not found in the readset/writeset, it is invalid.
		- If the status of the transaction is COMMMITTED or ABORTED, reads do nothing.
		- The value 'reads_' is populated by TxnProcessor (this contains the current values of the keys in the database, right?). The 'value' is set to the object within 'reads_key' (what is difference between reads_ and readset?)
	- Write() Writes the value value to the given record with Key key.
		- Makes sure the given key is in the writeset.
		- Nothing happens if the 'status_' of transaction is COMMITTED or ABORTED.
		- Sets the 'writes_[key]' to the given value. It also sets the 'reads_' for key to the value. Because for a write, one also needs to read?
	- Each transaction has a sets for readset, writeset. It also has hashtables for <Key, value> pairs for results for reads in reads_, and the ones written by the transaction in writes_.
	- unique_id_ is the transaction ID, assigned by TxnProcessor.

storage.h/storage.cc
	- Read(key, result, txn_unique_id)
		 - If the key is found in the data_ map (storage), then put data_[key] into result, return true.
		- txn_unique_id for MVCC and OCC?
	-Write(key, value, txn_unique_id)
		- Replaces the data_[key] data with value and sets the timestampe map of 'key' (of when it was last updated).
	- Timestamp(key)
		- Returns the timestamp at which the record with key was last updated. returns 0 if it has never been updated. Used for OCC.
	- InitStorage()
		- Initializes the Storage by writing to the data_ map from 0 to 1 million keys and setting the values to 0 (This also initializes the timestamp map for each key).
	- Lock(key)
	- Unlock(key)
	- CheckWrite(key, txn_unique_id)
	- data_ contains all the data of the database in a map, and timestamps_ is a map of the corresponding times at which each key was last updated.

txn_processor.h/txn_processor.cc
	- Constructor sets the mode (enum CCMode), initializes the thread pool tp_ (StaticThreadPool), and the next_unique_id to 1.
		- It chooses the locking mode, and constructs a corresponding lock manager (either A or B, i.e. exclusive or not). If the mode is MVCC, it initializes the MVCC storage, otherwise, initializes regular storage.
		- WTF? It sets atributes of threads. It sets the "affinity" attribute of the attr object to be the cpuset defined (this means that the thread scheduler will create threads on the given cpuset?) It then creates a thread called scheduler_, which executes StartScheduler (with a pointer to this TxnProcessor), which then calls RunScheduler()... which then calls the corresponding scheduler (serial, locking, OCC, etc.).
	- RunSerialScheduler()
		- While the thread pool is active, if there is a request in the txn_request_ AtomicQueue, we ExecuteTxn(txn). If the status of the executed transaction is COMPLETED_C, we ApplyWrites(txn) (this writes out the writes buffered in the transaction's writes_ buffer) and set the status to COMMITTED.

	- ExecuteTxn(txn)
		- for every item in the set of txn's readset, we try to read the value from storage. If it is there, we store the result in the txn's reads_ buffer.
		- We do the same for the writeset, but also put the returned results into the read buffer? This is because to check if it is in storage, we read it?
		- Run() - This function depends if the txn is Noop, Put,or RMW
		- Then, we push to the  completed_txns_ queue (not yet committed).
		- Then, the Processor, applies the writes if the status is correct, otherwise aborts, or dies. Then, we push the transaction unto the txn_results_ (already committed/aborted txns) queue.

	- RunLockingScheduler()
		- While the tp_ is active, if we have a txn in our txn_requests_ queue, pop one off. Then, for everything in its readset, try to acquire a lock from the lock manager. If the lock is not acquired, and the read and writesets have more than 1 element each, then release all of the locks acquired up to this point and exit the for loop.
		- If blocked is still false (we successfully acquired all the read locks necessary), then we try to acquire the write locks in a similar fashion.
		- Why do we need the condition writeset + readset > 1? We set blocked to TRUE before we check this?
		- If not blocked, we put the txn into the ready_txns_ queue (this queue is not atomic because the only one who accesses this is the Processor/Scheduler). If we failed to get the locks, we atomically increase the unique_id, give the transaction a new one, and put it back into the txn_requests_ queue.
		- while we have things in our completed_txns_ queue, we apply if necessary, or abort if necessary. Then, we release the locks, and return the result to txn_results_.
		- Then, we get unload the ready_txns_ queue by calling tp_.RunTask which sets a new thread from the pool running to execute this transaction.

mutex.h - a light wrapper around Pthread's mutex
	- The Mutex class had one declared mutex_. It is initialized using pthread_mutex_init in the constructor.
	- Lock() calls pthread_mutex_lock(&mutex_)
	- TryLock() tries to get the lock
	- Unlock() - calls pthread_mutex_unlock

	MutexRW?

