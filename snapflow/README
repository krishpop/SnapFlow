Addressing Write-Skew for Highly-Concurrent Snapshot Databases: A Faster Approach than Serializable Snapshot Isolation 
Jeremy Liu, David Marcano, Kshitijh Meelu, Krishnan Srinivasan

    Snapshot Isolation (SI) is a popular transactional isolation level that takes advantage of multi-version concurrency control schemes to support non-blocking reads—that is, reads do not block writes on the same data. At this isolation level, a transaction reads the latest version of the data written and committed before the given transaction’s start timestamp (the only exception being that the transaction reads versions of the data that it itself modified). In that sense, these transactions read from a ‘snapshot’ of the database immediately before starting. When ready to commit, a transaction T1 must ensure that no other transaction T2, which committed during T1’s execution (from its start timestamp to its commit timestamp), wrote data that T1 itself wrote. If this does not hold, T1 aborts. 
<<<<<<< HEAD
    This isolation level allows for more concurrency, as reads do not block writes, yet it compromises serializability to do so. The most notable case of SI’s violation of serializability is the write-skew phenomenon. This happens when allowing two transactions, which independently ensure consistency during an update, to run concurrently, causing overall inconsistency in the database.

In response to the SI’s write-skew problem, Serializable Snapshot Isolation (SSI) is another approach to concurrency control that enforces serializability on potential transactions with write-skew. It does this by performing look-ahead operations and dynamically detecting non-serializable executions before they are allowed to take place. Upon reaching such a scenario, SSI will choose to abort one transaction and keep the other transaction’s changes. One problem this creates is SSI will abort many non-serializable executions, as it uses the concept of a multiversion serialization graph to keep track of which concurrent transactions are not serializable. It does this by using the fact that write-skew occurs when a cycle of read-write dependencies is present in the graph. However, because discovering cycles in the graph is expensive to calculate, the algorithm instead opts to abort transactions where it finds in- and out-dependency edges on one transaction. As a result, the proposed SSI solution solves the serializability problem, but contains some potential areas for improvement. 

    A large number of modern databases use SI isolation levels because of its high throughput capacity and ease of implementation. Most databases implement SI optimistically, pessimistically, or both. But this is not always safe because of write-skew as mentioned above. SSI solves that problem but it sacrifices a lot of the benefit gained by SI. The SSI algorithm requires greater locking overhead and additional locking than SI when resolving read-write dependencies. In addition, it could result in false positives and thus unnecessary aborts of transactions [3].
    This project proposes that by knowing application semantic metadata (e.g. control flow), one is able to have an isolation level that produces higher throughput than SSI while still addressing the write-skew problem in SI. Using this, we can more accurately avoid the transactions that will have the write-skew problem. Instead of flagging all the potential transactions that may develop write-skew and sacrificing the concurrency on false positive transactions like in SSI, our system will be able to abort those transactions whose control flow is not the same at time of committing than at time of execution. This eliminates the need for locks held by concurrent transactions in SSI and thus increases throughput.
    Our plan is to develop four different implementations of concurrency control. Building on the application code from Assignment 2, we will create a deployable version of serialized MVCC, MVCC with SI, SSI, and our new version that verifies control flow before commit. We will then benchmark these implementations against a subset of transactions in order to determine the relative performance of our proposed method.


Works Cited

Berenson, Hal, et al. "A critique of ANSI SQL isolation levels." ACM SIGMOD Record. Vol. 24. No. 2. ACM, 1995.

Cahill, Michael J., Uwe Röhm, and Alan D. Fekete. "Serializable isolation for snapshot databases." ACM Transactions on Database Systems (TODS) 34.4 (2009): 20.

Larson, Per-Åke, et al. "High-performance concurrency control mechanisms for main-memory databases." Proceedings of the VLDB Endowment 5.4 (2011): 298-309.
=======
    
    This isolation level allows for more concurrency, as reads do not block writes, yet it compromises serializability to do so. The most notable case of SI’s violation of serializability is the write-skew phenomenon. This happens when allowing two transactions, which independently ensure consistency during an update, to run concurrently, causing overall inconsistency in the database.
In response to the SI’s write-skew problem, Serializable Snapshot Isolation (SSI) is another approach to concurrency control that enforces serializability on potential transactions with write-skew. It does this by performing look-ahead operations and dynamically detecting non-serializable executions before they are allowed to take place. Upon reaching such a scenario, SSI will choose to abort one transaction and keep the other transaction’s changes. One problem this creates is SSI will abort many non-serializable executions, as it uses the concept of a multiversion serialization graph to keep track of which concurrent transactions are not serializable. It does this by using the fact that write-skew occurs when a cycle of read-write dependencies is present in the graph. However, because discovering cycles in the graph is expensive to calculate, the algorithm instead opts to abort transactions where it finds in- and out-dependency edges on one transaction. As a result, the proposed SSI solution solves the serializability problem, but contains some potential areas for improvement.
 
    A large number of modern databases use SI isolation levels because of its high throughput capacity and ease of implementation. Most databases implement SI optimistically, pessimistically, or both. But this is not always safe because of write-skew as mentioned above. SSI solves that problem but it sacrifices a lot of the benefit gained by SI. The SSI algorithm requires greater locking overhead and additional locking than SI when resolving read-write dependencies. In addition, it could result in false positives and thus unnecessary aborts of transactions [3].
    
    This project proposes that by knowing application semantic metadata (e.g. control flow), one is able to have an isolation level that produces higher throughput than SSI while still addressing the write-skew problem in SI. Using this, we can more accurately avoid the transactions that will have the write-skew problem. Instead of flagging all the potential transactions that may develop write-skew and sacrificing the concurrency on false positive transactions like in SSI, our system will be able to abort those transactions whose control flow is not the same at time of committing than at time of execution. This eliminates the need for locks held by concurrent transactions in SSI and thus increases throughput.
    
    Our plan is to develop four different implementations of concurrency control. Building on the application code from Assignment 2, we will create a deployable version of serialized MVCC, MVCC with SI, SSI, and our new version that verifies control flow before commit. We will then benchmark these implementations against a subset of transactions in order to determine the relative performance of our proposed method.
>>>>>>> master
